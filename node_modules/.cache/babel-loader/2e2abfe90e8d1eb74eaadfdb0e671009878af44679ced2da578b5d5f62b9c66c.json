{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/KIIT0001/Desktop/web development/react js/Mysore-motors/mysor_/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/KIIT0001/Desktop/web development/react js/Mysore-motors/mysor_/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"onComplete\", \"onUpdate\", \"motionValue\", \"element\"],\n  _excluded2 = [\"motionValue\", \"onUpdate\", \"onComplete\", \"element\"];\nimport { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport '../../../../../motion-utils/dist/es/errors.mjs';\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { attachTimeline } from './waapi/utils/attach-timeline.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsLinearEasing } from './waapi/utils/supports-linear-easing.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n  return isGenerator(options.type) || options.type === \"spring\" || !isWaapiSupportedEasing(options.ease);\n}\nfunction pregenerateKeyframes(keyframes, options) {\n  /**\n   * Create a main-thread animation to pregenerate keyframes.\n   * We sample this at regular intervals to generate keyframes that we then\n   * linearly interpolate between.\n   */\n  const sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n    keyframes,\n    repeat: 0,\n    delay: 0,\n    isGenerator: true\n  }));\n  let state = {\n    done: false,\n    value: keyframes[0]\n  };\n  const pregeneratedKeyframes = [];\n  /**\n   * Bail after 20 seconds of pre-generated keyframes as it's likely\n   * we're heading for an infinite loop.\n   */\n  let t = 0;\n  while (!state.done && t < maxDuration) {\n    state = sampleAnimation.sample(t);\n    pregeneratedKeyframes.push(state.value);\n    t += sampleDelta;\n  }\n  return {\n    times: undefined,\n    keyframes: pregeneratedKeyframes,\n    duration: t - sampleDelta,\n    ease: \"linear\"\n  };\n}\nconst unsupportedEasingFunctions = {\n  anticipate,\n  backInOut,\n  circInOut\n};\nfunction isUnsupportedEase(key) {\n  return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n  constructor(options) {\n    super(options);\n    const {\n      name,\n      motionValue,\n      element,\n      keyframes\n    } = this.options;\n    this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n    this.resolver.scheduleResolve();\n  }\n  initPlayback(keyframes, finalKeyframe) {\n    var _a;\n    let {\n      duration = 300,\n      times,\n      ease,\n      type,\n      motionValue,\n      name,\n      startTime\n    } = this.options;\n    /**\n     * If element has since been unmounted, return false to indicate\n     * the animation failed to initialised.\n     */\n    if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n      return false;\n    }\n    /**\n     * If the user has provided an easing function name that isn't supported\n     * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n     * function. This will later get converted to a linear() easing function.\n     */\n    if (typeof ease === \"string\" && supportsLinearEasing() && isUnsupportedEase(ease)) {\n      ease = unsupportedEasingFunctions[ease];\n    }\n    /**\n     * If this animation needs pre-generated keyframes then generate.\n     */\n    if (requiresPregeneratedKeyframes(this.options)) {\n      const _this$options = this.options,\n        {\n          onComplete,\n          onUpdate,\n          motionValue,\n          element\n        } = _this$options,\n        options = _objectWithoutProperties(_this$options, _excluded);\n      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n      keyframes = pregeneratedAnimation.keyframes;\n      // If this is a very short animation, ensure we have\n      // at least two keyframes to animate between as older browsers\n      // can't animate between a single keyframe.\n      if (keyframes.length === 1) {\n        keyframes[1] = keyframes[0];\n      }\n      duration = pregeneratedAnimation.duration;\n      times = pregeneratedAnimation.times;\n      ease = pregeneratedAnimation.ease;\n      type = \"keyframes\";\n    }\n    const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, _objectSpread(_objectSpread({}, this.options), {}, {\n      duration,\n      times,\n      ease\n    }));\n    // Override the browser calculated startTime with one synchronised to other JS\n    // and WAAPI animations starting this event loop.\n    animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n    if (this.pendingTimeline) {\n      attachTimeline(animation, this.pendingTimeline);\n      this.pendingTimeline = undefined;\n    } else {\n      /**\n       * Prefer the `onfinish` prop as it's more widely supported than\n       * the `finished` promise.\n       *\n       * Here, we synchronously set the provided MotionValue to the end\n       * keyframe. If we didn't, when the WAAPI animation is finished it would\n       * be removed from the element which would then revert to its old styles.\n       */\n      animation.onfinish = () => {\n        const {\n          onComplete\n        } = this.options;\n        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n        onComplete && onComplete();\n        this.cancel();\n        this.resolveFinishedPromise();\n      };\n    }\n    return {\n      animation,\n      duration,\n      times,\n      type,\n      ease,\n      keyframes: keyframes\n    };\n  }\n  get duration() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      duration\n    } = resolved;\n    return millisecondsToSeconds(duration);\n  }\n  get time() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 0;\n    const {\n      animation\n    } = resolved;\n    return millisecondsToSeconds(animation.currentTime || 0);\n  }\n  set time(newTime) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.currentTime = secondsToMilliseconds(newTime);\n  }\n  get speed() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return 1;\n    const {\n      animation\n    } = resolved;\n    return animation.playbackRate;\n  }\n  set speed(newSpeed) {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.playbackRate = newSpeed;\n  }\n  get state() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return \"idle\";\n    const {\n      animation\n    } = resolved;\n    return animation.playState;\n  }\n  get startTime() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return null;\n    const {\n      animation\n    } = resolved;\n    // Coerce to number as TypeScript incorrectly types this\n    // as CSSNumberish\n    return animation.startTime;\n  }\n  /**\n   * Replace the default DocumentTimeline with another AnimationTimeline.\n   * Currently used for scroll animations.\n   */\n  attachTimeline(timeline) {\n    if (!this._resolved) {\n      this.pendingTimeline = timeline;\n    } else {\n      const {\n        resolved\n      } = this;\n      if (!resolved) return noop;\n      const {\n        animation\n      } = resolved;\n      attachTimeline(animation, timeline);\n    }\n    return noop;\n  }\n  play() {\n    if (this.isStopped) return;\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    if (animation.playState === \"finished\") {\n      this.updateFinishedPromise();\n    }\n    animation.play();\n  }\n  pause() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation\n    } = resolved;\n    animation.pause();\n  }\n  stop() {\n    this.resolver.cancel();\n    this.isStopped = true;\n    if (this.state === \"idle\") return;\n    this.resolveFinishedPromise();\n    this.updateFinishedPromise();\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    const {\n      animation,\n      keyframes,\n      duration,\n      type,\n      ease,\n      times\n    } = resolved;\n    if (animation.playState === \"idle\" || animation.playState === \"finished\") {\n      return;\n    }\n    /**\n     * WAAPI doesn't natively have any interruption capabilities.\n     *\n     * Rather than read commited styles back out of the DOM, we can\n     * create a renderless JS animation and sample it twice to calculate\n     * its current value, \"previous\" value, and therefore allow\n     * Motion to calculate velocity for any subsequent animation.\n     */\n    if (this.time) {\n      const _this$options2 = this.options,\n        {\n          motionValue,\n          onUpdate,\n          onComplete,\n          element\n        } = _this$options2,\n        options = _objectWithoutProperties(_this$options2, _excluded2);\n      const sampleAnimation = new MainThreadAnimation(_objectSpread(_objectSpread({}, options), {}, {\n        keyframes,\n        duration,\n        type,\n        ease,\n        times,\n        isGenerator: true\n      }));\n      const sampleTime = secondsToMilliseconds(this.time);\n      motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n    }\n    const {\n      onStop\n    } = this.options;\n    onStop && onStop();\n    this.cancel();\n  }\n  complete() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.finish();\n  }\n  cancel() {\n    const {\n      resolved\n    } = this;\n    if (!resolved) return;\n    resolved.animation.cancel();\n  }\n  static supports(options) {\n    const {\n      motionValue,\n      name,\n      repeatDelay,\n      repeatType,\n      damping,\n      type\n    } = options;\n    return supportsWaapi() && name && acceleratedValues.has(name) && motionValue && motionValue.owner && motionValue.owner.current instanceof HTMLElement &&\n    /**\n     * If we're outputting values to onUpdate then we can't use WAAPI as there's\n     * no way to read the value from WAAPI every frame.\n     */\n    !motionValue.owner.getProps().onUpdate && !repeatDelay && repeatType !== \"mirror\" && damping !== 0 && type !== \"inertia\";\n  }\n}\nexport { AcceleratedAnimation };","map":{"version":3,"names":["anticipate","backInOut","circInOut","DOMKeyframesResolver","noop","millisecondsToSeconds","secondsToMilliseconds","isGenerator","BaseAnimation","MainThreadAnimation","acceleratedValues","startWaapiAnimation","isWaapiSupportedEasing","attachTimeline","getFinalKeyframe","supportsLinearEasing","supportsWaapi","sampleDelta","maxDuration","requiresPregeneratedKeyframes","options","type","ease","pregenerateKeyframes","keyframes","sampleAnimation","_objectSpread","repeat","delay","state","done","value","pregeneratedKeyframes","t","sample","push","times","undefined","duration","unsupportedEasingFunctions","isUnsupportedEase","key","AcceleratedAnimation","constructor","name","motionValue","element","resolver","resolvedKeyframes","finalKeyframe","onKeyframesResolved","scheduleResolve","initPlayback","_a","startTime","owner","current","_this$options","onComplete","onUpdate","_objectWithoutProperties","_excluded","pregeneratedAnimation","length","animation","calcStartTime","pendingTimeline","onfinish","set","cancel","resolveFinishedPromise","resolved","time","currentTime","newTime","speed","playbackRate","newSpeed","playState","timeline","_resolved","play","isStopped","updateFinishedPromise","pause","stop","_this$options2","_excluded2","sampleTime","setWithVelocity","onStop","complete","finish","supports","repeatDelay","repeatType","damping","has","HTMLElement","getProps"],"sources":["C:/Users/KIIT0001/Desktop/web development/react js/Mysore-motors/mysor_/node_modules/motion/dist/es/framer-motion/dist/es/animation/animators/AcceleratedAnimation.mjs"],"sourcesContent":["import { anticipate } from '../../easing/anticipate.mjs';\nimport { backInOut } from '../../easing/back.mjs';\nimport { circInOut } from '../../easing/circ.mjs';\nimport { DOMKeyframesResolver } from '../../render/dom/DOMKeyframesResolver.mjs';\nimport '../../../../../motion-utils/dist/es/errors.mjs';\nimport { noop } from '../../../../../motion-utils/dist/es/noop.mjs';\nimport { millisecondsToSeconds, secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isGenerator } from '../generators/utils/is-generator.mjs';\nimport { BaseAnimation } from './BaseAnimation.mjs';\nimport { MainThreadAnimation } from './MainThreadAnimation.mjs';\nimport { acceleratedValues } from './utils/accelerated-values.mjs';\nimport { startWaapiAnimation } from './waapi/index.mjs';\nimport { isWaapiSupportedEasing } from './waapi/easing.mjs';\nimport { attachTimeline } from './waapi/utils/attach-timeline.mjs';\nimport { getFinalKeyframe } from './waapi/utils/get-final-keyframe.mjs';\nimport { supportsLinearEasing } from './waapi/utils/supports-linear-easing.mjs';\nimport { supportsWaapi } from './waapi/utils/supports-waapi.mjs';\n\n/**\n * 10ms is chosen here as it strikes a balance between smooth\n * results (more than one keyframe per frame at 60fps) and\n * keyframe quantity.\n */\nconst sampleDelta = 10; //ms\n/**\n * Implement a practical max duration for keyframe generation\n * to prevent infinite loops\n */\nconst maxDuration = 20000;\n/**\n * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.\n * WAAPI doesn't support spring or function easings so we run these as JS animation before\n * handing off.\n */\nfunction requiresPregeneratedKeyframes(options) {\n    return (isGenerator(options.type) ||\n        options.type === \"spring\" ||\n        !isWaapiSupportedEasing(options.ease));\n}\nfunction pregenerateKeyframes(keyframes, options) {\n    /**\n     * Create a main-thread animation to pregenerate keyframes.\n     * We sample this at regular intervals to generate keyframes that we then\n     * linearly interpolate between.\n     */\n    const sampleAnimation = new MainThreadAnimation({\n        ...options,\n        keyframes,\n        repeat: 0,\n        delay: 0,\n        isGenerator: true,\n    });\n    let state = { done: false, value: keyframes[0] };\n    const pregeneratedKeyframes = [];\n    /**\n     * Bail after 20 seconds of pre-generated keyframes as it's likely\n     * we're heading for an infinite loop.\n     */\n    let t = 0;\n    while (!state.done && t < maxDuration) {\n        state = sampleAnimation.sample(t);\n        pregeneratedKeyframes.push(state.value);\n        t += sampleDelta;\n    }\n    return {\n        times: undefined,\n        keyframes: pregeneratedKeyframes,\n        duration: t - sampleDelta,\n        ease: \"linear\",\n    };\n}\nconst unsupportedEasingFunctions = {\n    anticipate,\n    backInOut,\n    circInOut,\n};\nfunction isUnsupportedEase(key) {\n    return key in unsupportedEasingFunctions;\n}\nclass AcceleratedAnimation extends BaseAnimation {\n    constructor(options) {\n        super(options);\n        const { name, motionValue, element, keyframes } = this.options;\n        this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);\n        this.resolver.scheduleResolve();\n    }\n    initPlayback(keyframes, finalKeyframe) {\n        var _a;\n        let { duration = 300, times, ease, type, motionValue, name, startTime, } = this.options;\n        /**\n         * If element has since been unmounted, return false to indicate\n         * the animation failed to initialised.\n         */\n        if (!((_a = motionValue.owner) === null || _a === void 0 ? void 0 : _a.current)) {\n            return false;\n        }\n        /**\n         * If the user has provided an easing function name that isn't supported\n         * by WAAPI (like \"anticipate\"), we need to provide the corressponding\n         * function. This will later get converted to a linear() easing function.\n         */\n        if (typeof ease === \"string\" &&\n            supportsLinearEasing() &&\n            isUnsupportedEase(ease)) {\n            ease = unsupportedEasingFunctions[ease];\n        }\n        /**\n         * If this animation needs pre-generated keyframes then generate.\n         */\n        if (requiresPregeneratedKeyframes(this.options)) {\n            const { onComplete, onUpdate, motionValue, element, ...options } = this.options;\n            const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);\n            keyframes = pregeneratedAnimation.keyframes;\n            // If this is a very short animation, ensure we have\n            // at least two keyframes to animate between as older browsers\n            // can't animate between a single keyframe.\n            if (keyframes.length === 1) {\n                keyframes[1] = keyframes[0];\n            }\n            duration = pregeneratedAnimation.duration;\n            times = pregeneratedAnimation.times;\n            ease = pregeneratedAnimation.ease;\n            type = \"keyframes\";\n        }\n        const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, { ...this.options, duration, times, ease });\n        // Override the browser calculated startTime with one synchronised to other JS\n        // and WAAPI animations starting this event loop.\n        animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();\n        if (this.pendingTimeline) {\n            attachTimeline(animation, this.pendingTimeline);\n            this.pendingTimeline = undefined;\n        }\n        else {\n            /**\n             * Prefer the `onfinish` prop as it's more widely supported than\n             * the `finished` promise.\n             *\n             * Here, we synchronously set the provided MotionValue to the end\n             * keyframe. If we didn't, when the WAAPI animation is finished it would\n             * be removed from the element which would then revert to its old styles.\n             */\n            animation.onfinish = () => {\n                const { onComplete } = this.options;\n                motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));\n                onComplete && onComplete();\n                this.cancel();\n                this.resolveFinishedPromise();\n            };\n        }\n        return {\n            animation,\n            duration,\n            times,\n            type,\n            ease,\n            keyframes: keyframes,\n        };\n    }\n    get duration() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { duration } = resolved;\n        return millisecondsToSeconds(duration);\n    }\n    get time() {\n        const { resolved } = this;\n        if (!resolved)\n            return 0;\n        const { animation } = resolved;\n        return millisecondsToSeconds(animation.currentTime || 0);\n    }\n    set time(newTime) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.currentTime = secondsToMilliseconds(newTime);\n    }\n    get speed() {\n        const { resolved } = this;\n        if (!resolved)\n            return 1;\n        const { animation } = resolved;\n        return animation.playbackRate;\n    }\n    set speed(newSpeed) {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.playbackRate = newSpeed;\n    }\n    get state() {\n        const { resolved } = this;\n        if (!resolved)\n            return \"idle\";\n        const { animation } = resolved;\n        return animation.playState;\n    }\n    get startTime() {\n        const { resolved } = this;\n        if (!resolved)\n            return null;\n        const { animation } = resolved;\n        // Coerce to number as TypeScript incorrectly types this\n        // as CSSNumberish\n        return animation.startTime;\n    }\n    /**\n     * Replace the default DocumentTimeline with another AnimationTimeline.\n     * Currently used for scroll animations.\n     */\n    attachTimeline(timeline) {\n        if (!this._resolved) {\n            this.pendingTimeline = timeline;\n        }\n        else {\n            const { resolved } = this;\n            if (!resolved)\n                return noop;\n            const { animation } = resolved;\n            attachTimeline(animation, timeline);\n        }\n        return noop;\n    }\n    play() {\n        if (this.isStopped)\n            return;\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        if (animation.playState === \"finished\") {\n            this.updateFinishedPromise();\n        }\n        animation.play();\n    }\n    pause() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation } = resolved;\n        animation.pause();\n    }\n    stop() {\n        this.resolver.cancel();\n        this.isStopped = true;\n        if (this.state === \"idle\")\n            return;\n        this.resolveFinishedPromise();\n        this.updateFinishedPromise();\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        const { animation, keyframes, duration, type, ease, times } = resolved;\n        if (animation.playState === \"idle\" ||\n            animation.playState === \"finished\") {\n            return;\n        }\n        /**\n         * WAAPI doesn't natively have any interruption capabilities.\n         *\n         * Rather than read commited styles back out of the DOM, we can\n         * create a renderless JS animation and sample it twice to calculate\n         * its current value, \"previous\" value, and therefore allow\n         * Motion to calculate velocity for any subsequent animation.\n         */\n        if (this.time) {\n            const { motionValue, onUpdate, onComplete, element, ...options } = this.options;\n            const sampleAnimation = new MainThreadAnimation({\n                ...options,\n                keyframes,\n                duration,\n                type,\n                ease,\n                times,\n                isGenerator: true,\n            });\n            const sampleTime = secondsToMilliseconds(this.time);\n            motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);\n        }\n        const { onStop } = this.options;\n        onStop && onStop();\n        this.cancel();\n    }\n    complete() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.finish();\n    }\n    cancel() {\n        const { resolved } = this;\n        if (!resolved)\n            return;\n        resolved.animation.cancel();\n    }\n    static supports(options) {\n        const { motionValue, name, repeatDelay, repeatType, damping, type } = options;\n        return (supportsWaapi() &&\n            name &&\n            acceleratedValues.has(name) &&\n            motionValue &&\n            motionValue.owner &&\n            motionValue.owner.current instanceof HTMLElement &&\n            /**\n             * If we're outputting values to onUpdate then we can't use WAAPI as there's\n             * no way to read the value from WAAPI every frame.\n             */\n            !motionValue.owner.getProps().onUpdate &&\n            !repeatDelay &&\n            repeatType !== \"mirror\" &&\n            damping !== 0 &&\n            type !== \"inertia\");\n    }\n}\n\nexport { AcceleratedAnimation };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}